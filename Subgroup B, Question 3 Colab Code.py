# -*- coding: utf-8 -*-
"""Subgroup B, Question 3 Colab Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E5kzBuHXOljO-HiJWl_Dc-wzv8cFYK0Y
"""

!pip install mesa==1.2.1
!pip install matplotlib
!pip install adjustText

from mesa import Agent, Model
from mesa.space import MultiGrid
from mesa.time import RandomActivation
from mesa.time import SimultaneousActivation
from mesa.datacollection import DataCollector
import datetime
import random
import matplotlib.pyplot as plt
import numpy as np
import math
import heapq
from collections import deque
from matplotlib.patches import Wedge, Circle
from adjustText import adjust_text
import matplotlib.patches as mpatches
import matplotlib.lines as mlines
from collections import defaultdict

# Constants for the park
PARK_CENTER = (25, 25)
PARK_RADIUS = 20
WATER_RADIUS = 4  # The central water body
TIME_STEPS = 21  # 10 AM to 8 PM in 30-min intervals

# Define USS zones with angles and colors
uss_zones = {
    "Hollywood": {"angle_range": (265, 290), "color": "purple"},  # More visible at 6 o’clock
    "Minion Land": {"angle_range": (290, 360), "color": "yellow"},
    "Far Far Away": {"angle_range": (0, 65), "color": "grey"},  # Fixed crossing 0° issue
    "The Lost World": {"angle_range": (65, 130), "color": "green"},  # Adjusted to fit
    "Ancient Egypt": {"angle_range": (130, 170), "color": "brown"},  # Adjusted to prevent overlap
    "Sci-Fi City": {"angle_range": (170, 205), "color": "blue"},  # Shifted slightly
    "New York": {"angle_range": (205, 265), "color": "red"},  # Covers the rest
    #"Entrance": {"angle_range": (225, 270), "color": "gray"},
}

# Fixed locations for attractions
attractions = {
    "Hollywood": [(28, 18, "Pantages Theater"), (26, 19, "Mel's Mixtape"), (26,5,"Entrance")],
    "Minion Land": [(40, 24, "Minion Mayhem"), (35, 24, "Silly Swirly"), (34,23,"Buggie Boogie")],
    "Far Far Away": [(38, 29, "Shrek 4D"), (33, 39, "Puss in Boots"),(37,39,"Donkey LIVE"),(38,32,"Magic Potion Spin"),(34,27,"Enchanted Airways")],
    "The Lost World": [(16, 37, "Jurassic Rapids"), (26, 38, "Canopy Flyer"), (27, 39,"Dino-Soarin"), (30,38,"Water World")],
    "Ancient Egypt": [(13, 32, "Revenge of Mummy"), (17, 32, "Treasure Hunters")],
    "Sci-Fi City": [(11, 20, "Transformers"), (12, 24, "Cylon"), (10, 25, "Human"), (11, 23, "Accelerator")],
    "New York": [(22, 16, "Sesame Street Spaghetti Chase"), (23, 17, "Rhythm Truck"), (22, 17, "Lights Camera Action!")],
}
# Fixed locations for food stalls
food_stalls = {
    "Hollywood": [(29, 15, "Mel's Drive-In")],
    "Minion Land": [(38, 20, "Pop-A-Nana")],
    "Far Far Away": [(36, 27, "Goldilocks")],
    "The Lost World": [(28, 35, "Discovery Food Court")],
    "Ancient Egypt": [(15, 30, "Oasis Cafe")],
    "Sci-Fi City": [(12.5, 20, "StarBot Cafe")],
    "New York": [(20, 10, "Louie's NY Pizza")],
}
food_list = [
    ("Hollywood", "Mel's Drive-In"),
    ("Minion Land", "Pop-A-Nana"),
    ("Far Far Away", "Goldilocks"),
    ("The Lost World", "Discovery Food Court"),
    ("Ancient Egypt", "Oasis Cafe"),
    ("Sci-Fi City", "StarBot Cafe"),
    ("New York", "Louie's NY Pizza")
]

# Fixed locations for souvenir shops
souvenir_shops = {
    "Hollywood": [(25,14,"Candylicious"),(27,6,"Hello Kitty Studio Store"), (28,6,"Minion Mart"),(29,6,"Universal Studios Store"),(25,15,"UNIVRS")],
    "Minion Land": [(37,19,"Sweet Surrender"),(39,23,"Pop Store"), (34,22,"Fun Store")],
    "Far Far Away": [(35,26,"Fairy Godmother's Potion Shop")],
    "The Lost World": [(27,34,"The Dino-Store")],
    "Ancient Egypt": [(16,31,"Carter's Curiosities")],
    "Sci-Fi City": [(12,21,"Transformers shop")],
    "New York":[(21,9,"Big Bird's Emporium")]
}

shop_list = [
    ("Hollywood", "Candylicious"),
    ("Hollywood", "Hello Kitty Studio Store"),
    ("Hollywood", "Minion Mart"),
    ("Hollywood", "Universal Studios Store"),
    ("Hollywood", "UNIVRS"),
    ("Minion Land", "Sweet Surrender"),
    ("Minion Land", "Pop Store"),
    ("Minion Land", "Fun Store"),
    ("Far Far Away", "Fairy Godmother's Potion Shop"),
    ("The Lost World", "The Dino-Store"),
    ("Ancient Egypt", "Carter's Curiosities"),
    ("Sci-Fi City", "Transformers shop"),
    ("New York", "Big Bird's Emporium")
]

# Popularity weights for attractions (Higher values mean more popular-based off of wait time predictions)
attraction_weights = {
    "Hollywood": {"Pantages Theater": 2, "Mel's Mixtape": 1, "Entrance": 0},
    "Minion Land": {"Minion Mayhem": 5, "Silly Swirly": 3, "Buggie Boogie": 3},
    "Far Far Away": {"Shrek 4D": 4, "Puss in Boots": 3, "Donkey LIVE": 3, "Magic Potion Spin": 2, "Enchanted Airways": 3},
    "The Lost World": {"Jurassic Rapids": 5, "Canopy Flyer": 3, "Dino-Soarin": 2, "Water World": 5},
    "Ancient Egypt": {"Revenge of Mummy": 5, "Treasure Hunters": 3},
    "Sci-Fi City": {"Transformers": 5, "Cylon": 5, "Human": 5, "Accelerator": 3},
    "New York": {"Sesame Street Spaghetti Chase": 3, "Rhythm Truck": 2, "Lights Camera Action!": 4},
}

# Define ride capacities (max visitors per cycle) and operation times (steps per cycle)
ride_properties = {
    "Hollywood": {"Pantages Theater": {"capacity": 30, "duration": 3}, "Mel's Mixtape": {"capacity": 20, "duration": 2}, "Entrance": {"capacity": 50, "duration": 1}},
    "Minion Land": {"Minion Mayhem": {"capacity": 40, "duration": 5}, "Silly Swirly": {"capacity": 15, "duration": 3}, "Buggie Boogie": {"capacity": 10, "duration": 2}},
    "Far Far Away": {"Shrek 4D": {"capacity": 50, "duration": 6}, "Puss in Boots": {"capacity": 25, "duration": 4}, "Donkey LIVE": {"capacity": 30, "duration": 3},
                     "Magic Potion Spin": {"capacity": 15, "duration": 2}, "Enchanted Airways": {"capacity": 20, "duration": 4}},
    "The Lost World": {"Jurassic Rapids": {"capacity": 30, "duration": 5}, "Canopy Flyer": {"capacity": 20, "duration": 3}, "Dino-Soarin": {"capacity": 15, "duration": 2},
                       "Water World": {"capacity": 60, "duration": 8}},
    "Ancient Egypt": {"Revenge of Mummy": {"capacity": 25, "duration": 4}, "Treasure Hunters": {"capacity": 10, "duration": 2}},
    "Sci-Fi City": {"Transformers": {"capacity": 40, "duration": 5}, "Cylon": {"capacity": 30, "duration": 4}, "Human": {"capacity": 30, "duration": 4},
                    "Accelerator": {"capacity": 15, "duration": 2}},
    "New York": {"Sesame Street Spaghetti Chase": {"capacity": 20, "duration": 3}, "Rhythm Truck": {"capacity": 10, "duration": 2}, "Lights Camera Action!": {"capacity": 25, "duration": 4}},
}

Ride_operators_record ={
    "Hollywood": {"Pantages Theater": 3, "Mel's Mixtape": 3, "Entrance": 3},
    "Minion Land": {"Minion Mayhem": 3, "Silly Swirly": 3, "Buggie Boogie": 3},
    "Far Far Away": {"Shrek 4D": 3, "Puss in Boots": 3, "Donkey LIVE": 3, "Magic Potion Spin": 3, "Enchanted Airways": 3},
    "The Lost World": {"Jurassic Rapids": 3, "Canopy Flyer": 3, "Dino-Soarin": 3, "Water World": 3},
    "Ancient Egypt": {"Revenge of Mummy": 3, "Treasure Hunters": 3},
    "Sci-Fi City": {"Transformers": 3, "Cylon": 3, "Human": 3, "Accelerator": 3},
    "New York": {"Sesame Street Spaghetti Chase": 3, "Rhythm Truck": 3, "Lights Camera Action!": 3},
}

Cleaning_staff_record ={
    "Hollywood": 1,
    "Minion Land": 1,
    "Far Far Away": 1,
    "The Lost World": 1,
    "Ancient Egypt": 1,
    "Sci-Fi City": 1,
    "New York": 1,
}

Security_staff_record ={
    "Hollywood": 1,
    "Minion Land": 1,
    "Far Far Away": 1,
    "The Lost World": 1,
    "Ancient Egypt": 1,
    "Sci-Fi City": 1,
    "New York": 1,
}

Food_stall_staff_record ={
    "Hollywood": {"Mel's Drive-In":1},
    "Minion Land": {"Pop-A-Nana":1},
    "Far Far Away": {"Goldilocks":1},
    "The Lost World": {"Discovery Food Court":1},
    "Ancient Egypt": {"Oasis Cafe":1},
    "Sci-Fi City": {"StarBot Cafe":1},
    "New York": {"Louie's NY Pizza":1},
}

Souvenir_shop_staff_record ={
    "Hollywood": {"Candylicious":1,"Hello Kitty Studio Store":1, "Minion Mart":1,"Universal Studios Store":1,"UNIVRS":1},
    "Minion Land": {"Sweet Surrender":1,"Pop Store":1, "Fun Store":1},
    "Far Far Away": {"Fairy Godmother's Potion Shop":1},
    "The Lost World": {"The Dino-Store":1},
    "Ancient Egypt": {"Carter's Curiosities":1},
    "Sci-Fi City": {"Transformers shop":1},
    "New York": {"Big Bird's Emporium":1},
}

### Adjust the Duration of rides to accommodate for buffer for rides.

def adjust_duration(data, duration_change):
  for zone, rides in data.items():
    for ride, details in rides.items():
      duration = details["duration"]

      details["duration"] = int(duration + duration_change)

  return data

# adjust such that to account for 7 minute buffer
ride_properties = adjust_duration(ride_properties, 7)

ride_properties

from sys import last_traceback
class Visitor(Agent):
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.time_in_park = 0
        self.destination = None
        self.riding_time = 0
        self.current_zone = None
        self.hunger = 0
        self.eating_time = 0
        self.last_ride = None
        self.browsing = 0
        self.shop_prob = 0.1

    def step(self):
      self.time_in_park += 1

      if self.eating_time > 0:
          print(f"Visitor {self.unique_id} is eating for {self.eating_time} more steps.")
          self.eating_time -= 1
          if self.eating_time == 0:
              self.hunger = 0
              print(f"Visitor {self.unique_id} is no longer hungry.")
              self.destination = None
              return

      if self.riding_time > 0:
          print(f"Visitor {self.unique_id} is riding for {self.riding_time} more steps.")
          self.riding_time = 0
          return

      if self.browsing > 0:
          print(f"Visitor {self.unique_id} is browsing for {self.browsing} more steps.")
          self.browsing -= 1
          self.destination = None
          return

      # Increase hunger over time
      self.hunger += 1
      print(f"Visitor {self.unique_id} at {self.pos} - Hunger: {self.hunger}")

      if self.hunger > 5 and self.riding_time == 0:
        food = self.find_nearest_food()  #(zone, stall_name)
        if food:
            self.destination = food
            self.move_towards(food)
            print(f"Visitor {self.unique_id} is hungry and going to {food[1]}")

      # Goes shopping with probability of shopping probability assigned, else attractions when not hungry
      if not self.destination:
        if random.random() <= self.shop_prob:
          self.destination = self.choose_shop()
          print(f"Visitor {self.unique_id} chooses to shop at {self.destination}")
        else:
          self.destination = self.choose_attraction()
          print(f"Visitor {self.unique_id} chooses {self.destination}")

      self.move_towards(self.destination)

    def choose_shop(self):
      """Finds the nearest shop based on visitor's current position."""
      min_distance = float("inf")
      closest_shop = None

      for zone, shops in souvenir_shops.items():
          for (x, y, shop_name) in shops:
              path = self.model.get_shortest_path(self.pos, (x, y))
              dist = len(path)
              if dist < min_distance:
                  min_distance = dist
                  closest_shop = (zone, shop_name)
      return closest_shop

    def find_nearest_food(self):
      """Finds the nearest food stall based on visitor's current position."""
      current_zone = self.current_zone
      if current_zone is None:
          current_zone = self.get_zone_from_position(self.pos)
      closest_food = (current_zone, food_stalls[current_zone][0][2])
      return closest_food

    def start_eating(self):
        """Starts the eating process for the visitor."""
        self.eating_time = 2
        self.hunger = 0

    def start_browsing(self):
        """Starts the browsing process for the visitor."""
        self.browsing = 1

    def choose_attraction(self):
        """Selects an attraction based on popularity weights."""
        all_zones = list(attraction_weights.keys())
        chosen_zone = random.choice(all_zones)  # Pick a random zone

        rides = list(attraction_weights[chosen_zone].keys())
        weights = [attraction_weights[chosen_zone][ride] for ride in rides]  # Use weights for probability
        if self.last_ride in rides and len(rides) > 1:
            rides.remove(self.last_ride)
            weights.pop(attraction_weights[chosen_zone][self.last_ride])

        chosen_ride = random.choices(rides, weights=weights, k=1)[0]
        return chosen_zone, chosen_ride

    def get_zone_from_position(self, pos):
      """Determines which USS zone a given position belongs to."""
      x, y = pos
      dx, dy = x - PARK_CENTER[0], y - PARK_CENTER[1]  # Get relative position from center
      if dx == 0 and dy == 0:
          return None

      angle = (math.degrees(math.atan2(dy, dx)) + 360) % 360  # Compute angle and normalize

      for zone, data in uss_zones.items():
          start_angle, end_angle = data["angle_range"]
          if start_angle <= angle < end_angle:
              return zone  # Return the corresponding zone name
      return None

    def move_towards(self, destination):
      """Moves the visitor towards the destination, which could be a ride, food stall, or souvenir shop."""
      zone, name = destination

      # Initialize default values for destination types and coordinates
      target_x, target_y = None, None
      food_stall_found = False
      souvenir_shop_found = False
      ride_found = False

      # First, check if it's a food stall
      if zone in food_stalls:
          for x, y, stall_name in food_stalls[zone]:
              if stall_name == name:
                  food_stall_found = True
                  target_x, target_y = x, y
                  break

      # Then, check if it's a souvenir shop
      if not food_stall_found and zone in souvenir_shops:
          for x, y, shop_name in souvenir_shops[zone]:
              if shop_name == name:
                  souvenir_shop_found = True
                  target_x, target_y = x, y
                  break

      # If neither food stall nor souvenir shop, treat it as a ride (attraction)
      if not (food_stall_found or souvenir_shop_found) and zone in attractions:
          for x, y, attraction_name in attractions[zone]:
              if attraction_name == name:
                  ride_found = True
                  target_x, target_y = x, y
                  break

      # If none of the destinations are found, print an error
      if not (food_stall_found or souvenir_shop_found or ride_found):
          print(f"Error: {name} not found in {zone}")
          return

      # Introduce slight randomness in the final target position (±1 in x or y)
      target_x += random.choice([-1, 0, 1])
      target_y += random.choice([-1, 0, 1])

      dest_pos = (target_x, target_y)
      if (abs(self.pos[0] - target_x) <= 1) and (abs(self.pos[1] - target_y) <= 1):
        # Visitor is close enough, so handle the post-arrival actions
        if ride_found:
            self.enter_ride(zone, name)
        elif food_stall_found:
            self.start_eating()
        elif souvenir_shop_found:
            self.start_browsing()
      else:
          # Visitor is not at the target yet, so move towards it
          if self.pos != dest_pos:
              path = self.model.get_shortest_path(self.pos, dest_pos)
              if path:
                  self.model.grid.move_agent(self, path[min(4, len(path)-1)])
              if not path:  # If no valid path, pick another destination
                  self.destination = self.choose_attraction()
                  return

    def enter_ride(self, zone, ride):
        """Handles queueing and entering rides."""
        ride_data = self.model.ride_active[zone][ride]
        ride_queue = self.model.ride_queues[zone][ride]
        ride_capacity = ride_properties[zone][ride]["capacity"]

        if ride_data["occupied"] >= ride_capacity or ride_data["timer"] > 0:
            ride_queue.append(self)
        else:
            ride_data["occupied"] += 1
            self.riding_time = ride_properties[zone][ride]["duration"]


class Staff(Agent):
    def __init__(self, unique_id, model, stationed_at=None, dynamic=False, ride = None, food = None, shop = None):
        super().__init__(unique_id, model)
        self.stationed_at = stationed_at  # Fixed location
        self.dynamic = dynamic  # True if it's a dynamically assigned cleaning staff
        self.ride = ride
        self.food = food
        self.shop = shop

        # Fixed staff stay at their assigned positions
        if self.stationed_at:
            self.pos = self.stationed_at
        else:
            self.pos = model.random_position()

    def step(self):
        if self.stationed_at:
            return  # Fixed staff do not move

class ThemePark(Model):
    def __init__(self, width=50, height=50, num_visitors=1000):

        self.grid = MultiGrid(width, height, torus=False)
        self.schedule = SimultaneousActivation(self)
        self.zone_population = {zone: 0 for zone in uss_zones}
        self.dynamic_staff = []  # Track dynamically added staff
        self.start_time = datetime.datetime(2023, 1, 1, 10, 0)  # Start at 10:00 AM
        self.time_per_step = datetime.timedelta(minutes=30)

        # queue states
        self.ride_queues = {zone: {ride: deque() for ride in rides} for zone, rides in ride_properties.items()}
        self.ride_active = {zone: {ride: {"occupied": 0, "timer": 0} for ride in rides} for zone, rides in ride_properties.items()}

        # Visitor entrance scheduling
        self.total_visitors = num_visitors
        self.remaining_visitors = num_visitors
        self.entrance_queue = list(range(num_visitors))  # List of visitor IDs to enter

        self.staff_by_shop = defaultdict(list)
        self.staff_by_food = defaultdict(list)
        self.staff_by_ride = defaultdict(list)

        # Shuffle for randomness in entry order
        random.shuffle(self.entrance_queue)

        last_staff_id = num_visitors
        # Assign three staff to each attraction
        for zone, locations in attractions.items():
            for location in locations:
                for _ in range(3):  # Assign 3 staff members per attraction
                    position = (int(location[0]), int(location[1]))   # Get (x, y) coordinates
                    staff = Staff(last_staff_id, self, stationed_at=position, ride = location)
                    self.grid.place_agent(staff, position)
                    self.schedule.add(staff)
                    last_staff_id += 1

        # Assign one staff to each souvenir shop
        for zone, locations in souvenir_shops.items():
            for location in locations:
                position = (int(location[0]), int(location[1]))
                staff = Staff(last_staff_id, self, stationed_at=position, shop = location)
                self.grid.place_agent(staff, position)
                self.schedule.add(staff)
                last_staff_id += 1

        # Assign one staff to each food stall
        for zone, locations in food_stalls.items():
            for location in locations:
                position = (int(location[0]), int(location[1]))
                staff = Staff(last_staff_id, self, stationed_at=position, food = location)
                self.grid.place_agent(staff, position)
                self.schedule.add(staff)
                last_staff_id += 1

        # Assign one clening staff to each zone
        for zone in attractions.keys():
            position = (int(location[0]), int(location[1]))
            staff = Staff(last_staff_id, self, stationed_at=position)
            self.grid.place_agent(staff, position)
            self.schedule.add(staff)
            last_staff_id += 1

        #Assign one security to each zone
        for zone in attractions.keys():
            position = (int(location[0]), int(location[1]))
            staff = Staff(last_staff_id, self, stationed_at=position)
            self.grid.place_agent(staff, position)
            self.schedule.add(staff)
            last_staff_id += 1


    def calculate_wait_time(self, zone, ride):
      ride_data = self.ride_active[zone][ride]
      ride_queue = self.ride_queues[zone][ride]
      ride_duration = ride_properties[zone][ride]["duration"]
      ride_capacity = ride_properties[zone][ride]["capacity"] * int(30 / ride_duration)
      # Assuming each visitor spends the ride duration on a ride
      visitors_in_queue = len(ride_queue)
      wait_time = (visitors_in_queue / ride_capacity) #in terms of 30min steps
      return wait_time


    def get_zone_from_position(self, pos):
      """Determines which USS zone a given position belongs to."""
      x, y = pos
      dx, dy = x - PARK_CENTER[0], y - PARK_CENTER[1]  # Get relative position from center
      if dx == 0 and dy == 0:
          return None

      angle = (math.degrees(math.atan2(dy, dx)) + 360) % 360  # Compute angle and normalize

      for zone, data in uss_zones.items():
          start_angle, end_angle = data["angle_range"]
          if start_angle <= angle < end_angle:
              return zone  # Return the corresponding zone name
      return None

    def update_zone_population(self):
      """Counts the number of visitors in each USS zone."""
      self.zone_population = {zone: 0 for zone in uss_zones}  # Reset visitor count

      for agent in self.schedule.agents:
          if isinstance(agent, Visitor) and agent.get_zone_from_position(agent.pos):
              self.zone_population[agent.get_zone_from_position(agent.pos)] += 1

    def manage_cleaning_staff(self):
      # Assign cleaning staff to zones where population > 100
      for zone, count in self.zone_population.items():
        required_cleaning_staff = 1 + max(0, 1 + (count - 100) // 150) if count > 100 else 0
        # Count existing cleaning staff in the zone
        existing_cleaning_staff = Cleaning_staff_record[zone]
        # Add missing cleaning staff
        while existing_cleaning_staff < required_cleaning_staff:
            # Compute a central location for cleaning staff
            zone_positions = attractions.get(zone, []) + food_stalls.get(zone, []) + souvenir_shops.get(zone, [])
            if zone_positions:
                x_coords, y_coords = zip(*[pos[:2] for pos in zone_positions])
                center_x = int(sum(x_coords) // len(x_coords))  # Ensure integer
                center_y = int(sum(y_coords) // len(y_coords))  # Ensure integer
                center_position = (center_x, center_y)

                # Create new cleaning staff
                new_staff_id = max((agent.unique_id for agent in self.schedule.agents), default=0) + 1
                new_staff = Staff(new_staff_id, self, stationed_at=zone, dynamic=True)
                self.grid.place_agent(new_staff, center_position)
                self.dynamic_staff.append(new_staff)
                existing_cleaning_staff += 1
                # Update cleaning staff record
                Cleaning_staff_record [zone] += 1

      # Remove extra cleaning staff if visitors decrease
      if existing_cleaning_staff > required_cleaning_staff:
        for staff in self.dynamic_staff[:]:  # Iterate over a copy to avoid modification issues
          if staff.stationed_at == zone and staff.ride == None and staff.food == None and staff.shop == None:
              if staff.pos is not None and staff.unique_id in self.schedule._agents:
                  self.schedule.remove(staff)
                  if staff in self.grid._grid[int(staff.pos[0])][int(staff.pos[1])]:
                      self.grid.remove_agent(staff)
                      existing_cleaning_staff -= 1
                      # Update cleaning staff record
                      Cleaning_staff_record [zone] -= 1
                  self.dynamic_staff.remove(staff)

    def manage_security_staff(self):
      # Assign security staff to zones where population > 100
      for zone, count in self.zone_population.items():
        required_security_staff = 1 + max(0, 1 + (count - 100) // 150) if count > 100 else 0
        # Count existing security staff in the zone
        existing_security_staff = Security_staff_record[zone]
        # Add missing security staff
        while existing_security_staff < required_security_staff:
            # Compute a central location for security staff
            zone_positions = attractions.get(zone, []) + food_stalls.get(zone, []) + souvenir_shops.get(zone, [])
            if zone_positions:
                x_coords, y_coords = zip(*[pos[:2] for pos in zone_positions])
                center_x = int(sum(x_coords) // len(x_coords))  # Ensure integer
                center_y = int(sum(y_coords) // len(y_coords))  # Ensure integer
                center_position = (center_x, center_y)

                # Create new security staff
                new_staff_id = max((agent.unique_id for agent in self.schedule.agents), default=0) + 1
                new_staff = Staff(new_staff_id, self, stationed_at=zone, dynamic=True)
                self.grid.place_agent(new_staff, center_position)
                self.dynamic_staff.append(new_staff)
                existing_security_staff += 1
                # Update security staff record
                Security_staff_record[zone] += 1

      # Remove extra security staff if visitors decrease
      if existing_security_staff > required_security_staff:
        for staff in self.dynamic_staff[:]:  # Iterate over a copy to avoid modification issues
          if staff.stationed_at == zone and staff.ride == None and staff.food == None and staff.shop == None:
              if staff.unique_id in self.schedule._agents:
                  self.schedule.remove(staff)
                  if staff.pos is not None and staff in self.grid._grid[int(staff.pos[0])][int(staff.pos[1])]:
                      self.grid.remove_agent(staff)
                      existing_security_staff -= 1
                      # Update security staff record
                      Security_staff_record[zone] -= 1
                  self.dynamic_staff.remove(staff)

    def manage_dynamic_staff(self):
      # Check each ride for wait times and adjust staff accordingly
      for zone, rides in self.ride_queues.items():
          for ride, queue in rides.items():
              wait_time = self.calculate_wait_time(zone, ride)
              required_staff = 0

              if wait_time > 1:  # requires 2 step
                  required_staff = 2  #need 2 more staff
              elif wait_time > 0: # requires 1 step to clear queue
                  required_staff = 1  # need 1 more staff

              # Count how many staff are already dynamically assigned to this ride
              current_staff_count = Ride_operators_record[zone][ride] - 3

              # Add staff if needed
              while current_staff_count < required_staff:
                  ride_coord = None
                  for ride1 in attractions[zone]:
                    if ride1[2] == ride:  # If the ride name matches
                        ride_coord = (int(ride1[0]), int(ride1[1]))
                        break
                  if ride_coord is None:
                    continue
                  new_staff_id = max((agent.unique_id for agent in self.schedule.agents), default=0) + 1
                  new_staff = Staff(new_staff_id, self, stationed_at=zone, dynamic=True, ride = ride)
                  self.grid.place_agent(new_staff, ride_coord)
                  self.schedule.add(new_staff)
                  self.dynamic_staff.append(new_staff)
                  current_staff_count += 1
                  # Update ride opreator record
                  Ride_operators_record[zone][ride] += 1
                  if (zone, ride) not in self.staff_by_ride:
                      self.staff_by_ride[(zone, ride)] = []
                  self.staff_by_ride[(zone, ride)].append(new_staff)

              # Remove extra staff if needed
              if current_staff_count > required_staff:
                  staff_list = self.staff_by_ride.get((zone, ride), [])
                  if staff_list:
                      staff_to_remove = staff_list.pop()
                      if staff_to_remove and staff_to_remove.unique_id in self.schedule._agents:
                        self.schedule.remove(staff_to_remove)
                        self.grid.remove_agent(staff_to_remove)
                        self.dynamic_staff.remove(staff_to_remove)
                        current_staff_count -= 1
                        # Update ride opreator record
                        Ride_operators_record[zone][ride] -= 1


    def get_shortest_path(self, start, goal):
        """Uses A* algorithm to find the shortest path from start to goal."""
        open_set = []
        heapq.heappush(open_set, (0, start))  # (priority, node)

        came_from = {}  # Tracks how we reached each node
        g_score = {start: 0}  # Cost from start to each node
        f_score = {start: self.manhattan_distance(start, goal)}  # Estimated cost (g + h)

        visited = set()
        water_body_threshold = WATER_RADIUS ** 2  # Avoid recalculating square root

        while open_set:
            _, current = heapq.heappop(open_set)  # Node with lowest f-score

            if current == goal:
                return self.reconstruct_path(came_from, current)  # Build path

            if current in visited:
                continue
            visited.add(current)

            for neighbor in self.grid.get_neighborhood(current, moore=True, include_center=False):
                if ((neighbor[0] - PARK_CENTER[0]) ** 2 + (neighbor[1] - PARK_CENTER[1]) ** 2) < water_body_threshold:
                    continue  # Skip water body

                tentative_g_score = g_score[current] + 1  # Assume uniform cost (grid-based)
                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + self.manhattan_distance(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))

        return []  # No valid path found

    def reconstruct_path(self, came_from, current):
        """Reconstructs the path from goal to start."""
        path = []
        while current in came_from:
            path.append(current)
            current = came_from[current]
        path.reverse()
        return path

    def manhattan_distance(self, a, b):
        """Computes Manhattan distance as a heuristic."""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def step(self):
        """Runs a simulation step for the theme park."""
        current_time = self.start_time + self.time_per_step * self.schedule.time  # Calculate time
        print(f"Time: {current_time.strftime('%I:%M %p')}")
        # Handle visitor entrance in the first two steps
        if self.schedule.time < 2:  # Step 0 and Step 1
            if self.schedule.time == 0:
                num_to_enter = int(0.8 * self.total_visitors)  # 80% enter in step 0
            else:
                num_to_enter = self.remaining_visitors  # The rest enter in step 1

            entry_points = [(25, 5), (24, 5), (26, 5)]
            for _ in range(num_to_enter):
                if self.entrance_queue:
                  visitor_id = self.entrance_queue.pop(0)
                  personality = random.choice(["explorer", "thrill-seeker", "family-oriented"])
                  visitor = Visitor(visitor_id, self)

                  # Choose a random entry point
                  entry_point = random.choice(entry_points)

                  # Place the visitor at the chosen entry point
                  self.grid.place_agent(visitor, entry_point)
                  self.schedule.add(visitor)

                  print(f"Visitor {visitor_id} enters from {entry_point}")

            self.remaining_visitors -= num_to_enter  # Update count of visitors left to enter

        if current_time.hour == 18 and current_time.minute >= 30 or current_time.hour >= 19:
            self.make_visitors_leave()

        # Print the number of workers at each ride in each zone
        print("\nRide operating staff at each ride per zone:")
        for zone, rides in Ride_operators_record.items():
            print(f"  Zone: {zone}")
            for ride in rides:
                queue_count = self.ride_queues[zone][ride]
                print(f"    Ride: {ride}, Number of visitors in queue: {queue_count}")
                worker_count =  Ride_operators_record[zone][ride]
                print(f"    Ride: {ride}, Number of Staff: {worker_count}")

        # Print the number of food stall staff at each zone
        print("\nFood stall staff at each zone:")
        for zone, stall in Food_stall_staff_record.items():
            print(f"  Zone: {zone}")
            for stall_name, staff_count in stall.items():
                print(f"    Food Stall: {stall_name}, Number of Staff: {staff_count}")

        # Print the number of souvenir shop staff at each zone
        print("\nSouvenir shop staff at each zone:")
        for zone, shop in Souvenir_shop_staff_record.items():
            print(f"  Zone: {zone}")
            for shop_name, staff_count in shop.items():
                print(f"    Souvenir Shop: {shop_name}, Number of Staff: {staff_count}")

        # Print the number of cleaning staff at each zone
        print("\nCleaning staff at each zone:")
        for zone in Cleaning_staff_record:
            #print(f"  Zone: {zone}, Number of visitors: {self.zone_population}")
            print(f"  Zone: {zone}, Number of Cleaning Staff: {Cleaning_staff_record[zone]}")

        # Print number of Security staff at each zone
        print("\nSecurity staff at each zone:")
        for zone in Security_staff_record:
            print(f"  Zone: {zone}, Number of Security Staff: {Security_staff_record[zone]}")

        self.schedule.step()
        self.update_zone_population()  # Update visitor counts
        self.update_rides()  # Update ride operations
        self.manage_cleaning_staff()
        self.manage_security_staff()
        self.manage_dynamic_staff()
        self.update_shop_food()

    def update_shop_food(self):
        """Handle food and souvenir shop operations."""
        food_visitors = defaultdict(int)  # Track number of visitors per food stall
        shop_visitors = defaultdict(int)  # Track number of visitors per shop
        required_staff1 = defaultdict(int)
        required_staff2 = defaultdict(int)

        for agent in self.schedule.agents:
            if isinstance(agent, Visitor) and agent.destination in shop_list:
                if agent.destination not in shop_visitors:
                    shop_visitors[agent.destination] = 0
                shop_visitors[agent.destination] += 1  # Count visitors in each shop
            elif isinstance(agent, Visitor) and agent.destination in food_list:
                if agent.destination not in food_visitors:
                    food_visitors[agent.destination] = 0
                food_visitors[agent.destination] += 1  # Count visitors in each food stall

        # Adjust staff allocation based on visitors
        for (zone, shop_name), visitor_count in shop_visitors.items():
            if visitor_count >= 10:
                required_staff1[shop_name] = 2
            elif visitor_count >= 3:
                required_staff1[shop_name] = 1
            else:
                required_staff1[shop_name] = 0
            # Count how many staff are already dynamically assigned to this shop
            current_dstaff_count = Souvenir_shop_staff_record[zone][shop_name] - 1
            # Add staff if needed
            while current_dstaff_count < required_staff1[shop_name]:
                for shop in souvenir_shops[zone]:
                  if shop[2] == shop_name:  # If the shop name matches
                      shop_coord = tuple(map(int, shop[:2]))
                      break
                if shop_coord is None:
                    continue
                new_staff_id = max((agent.unique_id for agent in self.schedule.agents), default=0) + 1
                new_staff = Staff(new_staff_id, self, stationed_at=zone, dynamic=True, shop = shop_name)
                self.grid.place_agent(new_staff, shop_coord)
                self.schedule.add(new_staff)
                self.dynamic_staff.append(new_staff)
                current_dstaff_count += 1
                # Update shop record
                Souvenir_shop_staff_record[zone][shop_name] += 1
                if (zone, shop_name) not in self.staff_by_shop:
                    self.staff_by_shop[(zone, shop_name)] = []
                self.staff_by_shop[(zone, shop_name)].append(new_staff)

            # Remove extra staff if needed
            if current_dstaff_count > required_staff1[shop_name]:
                staff_list = self.staff_by_shop.get((zone, shop_name), [])
                if staff_list:
                    staff_to_remove = staff_list.pop()
                    if staff_to_remove and staff_to_remove.unique_id in self.schedule._agents:
                      self.schedule.remove(staff_to_remove)
                      self.grid.remove_agent(staff_to_remove)
                      self.dynamic_staff.remove(staff_to_remove)
                      current_dstaff_count -= 1
                      # Update ride opreator record
                      Souvenir_shop_staff_record[zone][shop_name] -= 1

        for (zone, food_stall), visitor_count in food_visitors.items():
            if visitor_count >= 10:
                required_staff2[food_stall] = 2
            elif visitor_count >= 3:
                required_staff2[food_stall] = 1
            else:
                required_staff2[food_stall] = 0  # If less than 3 visitors, no extra staff

            # Count how many staff are already dynamically assigned to this shop
            current_dstaff_count = Food_stall_staff_record[zone][food_stall] - 1
            # Add staff if needed
            while current_dstaff_count < required_staff2[food_stall]:
                for food in food_stalls[zone]:
                    if food[2] == food_stall:  # If the shop name matches
                        food_coord = tuple(map(int, food[:2]))
                if food_coord is None:
                    continue
                new_staff_id = max((agent.unique_id for agent in self.schedule.agents), default=0) + 1
                new_staff = Staff(new_staff_id, self, stationed_at=zone, dynamic=True, food = food_stall)
                self.grid.place_agent(new_staff, food_coord)
                self.schedule.add(new_staff)
                self.dynamic_staff.append(new_staff)
                current_dstaff_count += 1
                # Update shop record
                if food_stall not in food_stalls[zone]:
                    continue
                Food_stall_staff_record[zone][food_stall] += 1
                if (zone, food_stall) not in self.staff_by_food:
                    self.staff_by_food[(zone, food_stall)] = []
                self.staff_by_food[(zone, food_stall)].append(new_staff)

            # Remove extra staff if needed
            if current_dstaff_count > required_staff2[food_stall]:
                staff_list = self.staff_by_food.get((zone, food_stall), [])
                if staff_list:
                    staff_to_remove = staff_list.pop()
                    if staff_to_remove and staff_to_remove.unique_id in self.schedule._agents:
                      self.schedule.remove(staff_to_remove)
                      self.grid.remove_agent(staff_to_remove)
                      self.dynamic_staff.remove(staff_to_remove)
                      current_dstaff_count -= 1
                      # Update ride opreator record
                      if food_stall not in food_stalls[zone]:
                          return
                      Food_stall_staff_record[zone][food_stall] -= 1


    def update_rides(self):
        """Handle ride operation cycles and move visitors from queue to ride."""
        for zone, rides in self.ride_active.items():
            for ride, data in rides.items():
                ride_duration = ride_properties[zone][ride]["duration"]
                ride_capacity = ride_properties[zone][ride]["capacity"] * int(30/ride_duration) # Take into account each simulation step is 30min

                # Check if ride is running
                if data["timer"] > 0:
                    data["timer"] = 0  # Reduce timer
                    if data["timer"] == 0:
                        data["occupied"] = 0  # Ride empties
                else:
                    # Load new visitors if there's space
                    while self.ride_queues[zone][ride] and data["occupied"] < ride_capacity:
                        visitor = self.ride_queues[zone][ride].popleft()
                        data["occupied"] += 1
                        visitor.riding_time = ride_duration  # Set visitor's ride time

                    # Start new ride cycle if visitors are inside
                    if data["occupied"] > 0:
                        data["timer"] = ride_duration

    def make_visitors_leave(self):
        """Gradually makes visitors exit the park."""
        # Calculate the number of visitors to remove based on the time
        visitors_to_remove = []

        # Number of visitors leaving gradually
        num_leaving = max(1, int(self.remaining_visitors * 0.20))
        visitors_left = [visitor for visitor in self.schedule.agents if isinstance(visitor, Visitor)]

        for visitor in visitors_left[:num_leaving]:
            visitors_to_remove.append(visitor)

        # Remove the selected visitors from the grid and schedule
        for visitor in visitors_to_remove:
            self.grid.remove_agent(visitor)
            self.schedule.remove(visitor)
            self.remaining_visitors -= 1  # Update the count of remaining visitors

        if self.remaining_visitors == 0:
            print("All visitors have left the park.")

def plot_theme_park(model, step):
    fig, ax = plt.subplots(figsize=(10, 10))
    ax.set_xlim(5, 45)
    ax.set_ylim(5, 45)

    # Plot USS Zones
    legend_patches = []
    for zone, data in uss_zones.items():
        wedge = Wedge(PARK_CENTER, PARK_RADIUS, *data["angle_range"], color=data["color"], alpha=0.3)
        ax.add_patch(wedge)
        legend_patches.append(mpatches.Patch(color=data["color"], label=zone))  # Add zone to legend

    # Plot central water body
    ax.add_patch(Circle(PARK_CENTER, WATER_RADIUS, color="blue", alpha=0.1))
    # Add label for the water body at the center
    ax.text(PARK_CENTER[0], PARK_CENTER[1], "Water Body",
        fontsize=12, color="blue", fontweight="bold",
        ha="center", va="center",
        bbox=dict(facecolor='white', edgecolor='blue', boxstyle='round,pad=0.3', alpha=0.8))


    texts = []

    # Plot Attractions, Food Stalls, and Souvenir Shops
    categories = [
        (attractions, 'pink', "Attractions"),
        (food_stalls, 'orange', "Food Stalls"),
        (souvenir_shops, 'purple', "Souvenir Shops")
    ]

    for category, color, label in categories:
        for points in category.values():
            for x, y, name in points:
                ax.scatter(x, y, color=color, s=50, label=label if label not in [p.get_label() for p in legend_patches] else "")
                text = ax.text(x, y, name, fontsize=8, ha="center", va="center",
                               bbox=dict(facecolor='white', alpha=0.6, edgecolor='none'))
                texts.append(text)

    # Plot Agents (Visitors and Staff)
    for agent in model.schedule.agents:
        if isinstance(agent, Visitor):
            ax.scatter(*agent.pos, color='blue', s=3)  # Visitors
        elif isinstance(agent, Staff):
            ax.scatter(*agent.pos, color='green', s=3)  # Staff

    # Automatically adjust text positions to prevent overlap
    adjust_text(texts, expand=(1.2, 1.5), arrowprops=dict(arrowstyle='->', color='gray', lw=0.5))

    # Create a circular legend marker for Visitors and Staff
    visitor_marker = mlines.Line2D([], [], color='blue', marker='o', linestyle='None', markersize=4, label="Visitor")
    staff_marker = mlines.Line2D([], [], color='green', marker='o', linestyle='None', markersize=4, label="Staff")

    # Add Visitors and Staff to the legend
    legend_patches.extend([visitor_marker, staff_marker])
    legend_patches.extend([
        mlines.Line2D([], [], color='pink', marker='o', linestyle='None', markersize=8, label="Attractions"),
        mlines.Line2D([], [], color='orange', marker='o', linestyle='None', markersize=8, label="Food Stalls"),
        mlines.Line2D([], [], color='purple', marker='o', linestyle='None', markersize=8, label="Souvenir Shops"),
    ])
    ax.legend(handles=legend_patches, loc='upper right', fontsize=10)

    plt.show()


park = ThemePark()
for s in range(TIME_STEPS):
    park.step()
    plot_theme_park(park, s)