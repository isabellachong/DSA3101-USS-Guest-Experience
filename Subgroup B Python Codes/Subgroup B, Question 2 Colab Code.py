# -*- coding: utf-8 -*-
"""Main Git Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11fr7zOwdiZqK3TceE4EOrPt1Y9Zl4KHp

# Subgroup B Question 2

Addressing Subgroup B Question 2: Optimization of Attraction Layouts and Schedules


*   Simulate guest flow under different layouts or schedules using queueing theory or agent-based modeling
*   Assess the impact on wait times, satisfaction, and revenue



Key Factors affecting demand of attraction/services (From Subgroup B Question 1):h

## Loading Libraries
"""

!pip install simpy
!pip install mesa==1.2.1
!pip install matplotlib
!pip install adjustText

# Importing Libraries
from mesa import Agent, Model
from mesa.space import MultiGrid
from mesa.time import RandomActivation
from mesa.time import SimultaneousActivation
from mesa.datacollection import DataCollector
import random
import matplotlib.pyplot as plt
import numpy as np
from collections import deque
from matplotlib.patches import Wedge, Circle
from adjustText import adjust_text
import matplotlib.patches as mpatches
import matplotlib.lines as mlines
import pandas as pd
import seaborn as sns
from scipy.stats import norm
from matplotlib import cm
import simpy
import random
import math
import datetime
import scipy.stats as stats

"""## Loading Dataset

USS Attraction/Services Data:

1.  List of all rides and restaurant or shop services present and operating in 2025.
2.  Data includes Name of Attraction/Services, Type, Capacity, Interval and Distance from Entrance.

Capacity and Interval of the attraction/services are estimated. (Online pictures and a typical average of operations)

*Interval of slides = Duration of Ride + Estimated of 7 minute buffer (Getting on and off rides + safety protocols)

Unlike the attractions (typically rides), Restaurant/Shops does not have a fixed duration per session, hence estimation of visitors' duration of stay was used to replace the missing values.

### Survey Response Data
"""

survey_data = pd.read_excel("uss_survey_responses.xlsx")
survey_data.head()

"""### Park Visual (Fixing Location on Map)"""

# Constants for the park
PARK_CENTER = (25, 25)
PARK_RADIUS = 20
WATER_RADIUS = 5  # The central water body
TIME_STEPS = 20  # 10 AM to 8 PM in 30 min intervals

# Define USS zones with angles and colors
uss_zones = {
    "Hollywood": {"angle_range": (265, 290), "color": "purple"},  # More visible at 6 o’clock
    "Minion Land": {"angle_range": (290, 360), "color": "yellow"},
    "Far Far Away": {"angle_range": (0, 65), "color": "grey"},  # Fixed crossing 0° issue
    "The Lost World": {"angle_range": (65, 130), "color": "green"},  # Adjusted to fit
    "Ancient Egypt": {"angle_range": (130, 170), "color": "brown"},  # Adjusted to prevent overlap
    "Sci-Fi City": {"angle_range": (170, 205), "color": "blue"},  # Shifted slightly
    "New York": {"angle_range": (205, 265), "color": "red"},  # Covers the rest
    #"Entrance": {"angle_range": (225, 270), "color": "gray"},
}

# Fixed locations for attractions
attractions = {
    "Hollywood": [(28, 18, "Pantages Theater"), (26, 19, "Mel's Mixtape"), (26,5,"Entrance")],
    "Minion Land": [(40, 25, "Minion Mayhem"), (35, 24, "Silly Swirly"), (34,23,"Buggie Boogie")],
    "Far Far Away": [(38, 29, "Shrek 4D"), (33, 39, "Puss in Boots"),(37,39,"Donkey LIVE"),(38,32,"Magic Potion Spin"),(34,27,"Enchanted Airways")],
    "The Lost World": [(16, 37, "Jurassic Rapids"), (26, 38, "Canopy Flyer"), (27, 39,"Dino-Soarin"), (30,38,"Water World")],
    "Ancient Egypt": [(13, 32, "Revenge of Mummy"), (17, 32, "Treasure Hunters")],
    "Sci-Fi City": [(11, 20, "Transformers"), (10, 24, "Cylon"), (10, 25, "Human"), (10, 23, "Accelerator")],
    "New York": [(22, 16, "Sesame Street Spaghetti Chase"), (23, 17, "Rhythm Truck"), (22, 17, "Lights Camera Action!")],
}
# Fixed locations for food stalls
food_stalls = {
    "Hollywood": [(29, 15, "Mel's Drive-In")],
    "Minion Land": [(38, 20, "Pop-A-Nana")],
    "Far Far Away": [(36, 27, "Goldilocks")],
    "The Lost World": [(28, 35, "Discovery Food Court")],
    "Ancient Egypt": [(15, 30, "Oasis Cafe")],
    "Sci-Fi City": [(12.5, 20, "StarBot Cafe")],
    "New York": [(20, 10, "Louie's NY Pizza")],
}

# Fixed locations for souvenir shops
souvenir_shops = {
    "Hollywood": [(25,14,"Candylicious"),(27,6,"Hello Kitty Studio Store"), (28,6,"Minion Mart"),(29,6,"Universal Studios Store"),(25,15,"UNIVRS")],
    "Minion Land": [(37,19,"Sweet Surrender"),(39,24,"Pop Store"), (34,22,"Fun Store")],
    "Far Far Away": [(35,26,"Fairy Godmother's Potion Shop")],
    "The Lost World": [(27,34,"The Dino-Store")],
    "Ancient Egypt": [(16,31,"Carter's Curiosities")],
    "Sci-Fi City": [(12,21,"Transformers shop")],
    "New York":[(21,9,"Big Bird's Emporium")]
}

# Popularity weights for attractions (Higher values mean more popular-based off of wait time predictions)
attraction_weights = {
    "Hollywood": {"Pantages Theater": 5, "Mel's Mixtape": 4, "Entrance": 0},
    "Minion Land": {"Minion Mayhem": 3, "Silly Swirly": 2, "Buggie Boogie": 3},
    "Far Far Away": {"Shrek 4D": 9, "Puss in Boots": 12, "Donkey LIVE": 3, "Magic Potion Spin": 1, "Enchanted Airways": 5},
    "The Lost World": {"Jurassic Rapids": 11, "Canopy Flyer": 8, "Dino-Soarin": 6, "Water World": 5},
    "Ancient Egypt": {"Revenge of Mummy": 10, "Treasure Hunters": 7},
    "Sci-Fi City": {"Transformers": 14, "Cylon": 13, "Human": 15, "Accelerator": 2},
    "New York": {"Sesame Street Spaghetti Chase": 3, "Rhythm Truck": 2, "Lights Camera Action!": 4},
}

# Define ride capacities (max visitors per cycle) and operation times (steps per cycle)
ride_properties = {
    "Hollywood": {"Pantages Theater": {"capacity": 30, "duration": 3}, "Mel's Mixtape": {"capacity": 20, "duration": 2}, "Entrance": {"capacity": 100, "duration": 1}},
    "Minion Land": {"Minion Mayhem": {"capacity": 40, "duration": 5}, "Silly Swirly": {"capacity": 15, "duration": 3}, "Buggie Boogie": {"capacity": 10, "duration": 2}},
    "Far Far Away": {"Shrek 4D": {"capacity": 50, "duration": 6}, "Puss in Boots": {"capacity": 25, "duration": 4}, "Donkey LIVE": {"capacity": 30, "duration": 3},
                     "Magic Potion Spin": {"capacity": 15, "duration": 2}, "Enchanted Airways": {"capacity": 20, "duration": 4}},
    "The Lost World": {"Jurassic Rapids": {"capacity": 30, "duration": 5}, "Canopy Flyer": {"capacity": 20, "duration": 3}, "Dino-Soarin": {"capacity": 15, "duration": 2},
                       "Water World": {"capacity": 60, "duration": 8}},
    "Ancient Egypt": {"Revenge of Mummy": {"capacity": 25, "duration": 4}, "Treasure Hunters": {"capacity": 10, "duration": 2}},
    "Sci-Fi City": {"Transformers": {"capacity": 40, "duration": 5}, "Cylon": {"capacity": 30, "duration": 4}, "Human": {"capacity": 30, "duration": 4},
                    "Accelerator": {"capacity": 15, "duration": 2}},
    "New York": {"Sesame Street Spaghetti Chase": {"capacity": 20, "duration": 3}, "Rhythm Truck": {"capacity": 10, "duration": 2}, "Lights Camera Action!": {"capacity": 25, "duration": 4}},
}

### Adjust the Duration of rides to accommodate for buffer for rides.

def adjust_duration(data, duration_change):
  for zone, rides in data.items():
    for ride, details in rides.items():
      duration = details["duration"]

      details["duration"] = int(duration + duration_change)

  return data

# adjust such that to account for 7 minute buffer
ride_properties = adjust_duration(ride_properties, 7)

ride_properties

"""## ABM

### Visitor Class

Why are the visitor movements spontaneous?

Based on our survey respondents, 266/500 respondents suggest that they do spontaneous exploration hence our model followed the majority.
"""

class Visitor(Agent):
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.time_in_park = 0
        self.destination = None
        self.riding_time = 0
        self.current_zone = None

    def step(self):
        self.time_in_park += 1

        if self.riding_time > 0:  # If on a ride, decrement ride time
            self.riding_time -= 1
            return
        # Check which zone the visitor is in
        self.current_zone = self.model.get_zone_from_position(self.pos)

        if not self.destination or random.random() < 0.2:  # 20% chance to reconsider destination
            self.destination = self.choose_attraction()

        self.move_towards(self.destination)

    def choose_attraction(self):
        """Selects an attraction based on popularity weights."""
        # Calculate total popularity for each zone
      	zone_popularity = {zone: sum(attraction_weights[zone].values()) for zone in attraction_weights}

      	# Create lists of zones and their corresponding popularity weights
      	all_zones = list(zone_popularity.keys())
      	weights = [zone_popularity[zone] ** self.exponential for zone in all_zones]

      	# Select a zone based on the calculated weights
      	chosen_zone = random.choices(all_zones, weights=weights, k=1)[0]

      	# Get the list of rides and their weights for the chosen zone
      	rides = list(attraction_weights[chosen_zone].keys())
      	ride_weights = [attraction_weights[chosen_zone][ride] ** self.exponential for ride in rides]
      	# Normalize the ride weights
      	total_weight = sum(ride_weights)
      	normalized_weights = [w / total_weight for w in ride_weights]

        # Remove the last ride if it exists
        if self.last_ride in rides and len(rides) > 1:
            last_ride_index = rides.index(self.last_ride)
            rides.remove(self.last_ride)
            normalized_weights.pop(last_ride_index)  # Remove the corresponding weight

        # Choose a ride based on the normalized weights
        chosen_ride = random.choices(rides, weights=normalized_weights, k=1)[0]

        return chosen_zone, chosen_ride

    def move_towards(self, destination):
        """Move towards the chosen attraction."""
        zone, ride = destination
        dest_pos = next((x, y) for x, y, name in attractions[zone] if name == ride)

        if self.pos == dest_pos:
            self.enter_ride(zone, ride)
        else:
            path = self.model.get_shortest_path(self.pos, dest_pos)
            if path:
                self.model.grid.move_agent(self, path[min(3, len(path)-1)])
            if not path:  # If no valid path, pick another destination
              self.destination = self.choose_attraction()
              return

    def enter_ride(self, zone, ride):
        """Handles queueing and entering rides."""
        ride_data = self.model.ride_active[zone][ride]
        ride_queue = self.model.ride_queues[zone][ride]
        ride_capacity = ride_properties[zone][ride]["capacity"]

        if ride_data["occupied"] >= ride_capacity or ride_data["timer"] > 0:
            if len(ride_queue) < 3 * ride_capacity:  # Limit queue size
                ride_queue.append(self)

            else:
                self.destination = None  # Look for a new ride
        else:
            ride_data["occupied"] += 1
            self.riding_time = ride_properties[zone][ride]["duration"]

"""### Themepark Class

Considering Visitor Counts from 2010-2022:

Average annual visitor count: 3,246,000

Converting that to visitors per day: 9017 which we rounded off to 9000 for simulation purposes.
"""

class ThemePark(Model):
    def __init__(self, width=50, height=50, num_visitors=9000):

        self.grid = MultiGrid(width, height, torus=False)
        self.schedule = SimultaneousActivation(self)
        self.zone_population = {zone: 0 for zone in uss_zones}
        self.start_time = datetime.datetime(2023, 1, 1, 10, 0)  # Start at 10:00 AM
        self.time_per_step = datetime.timedelta(minutes=30)
        self.wait_time_records = {
            "attractions": {zone: {ride: [] for ride in rides} for zone, rides in ride_properties.items()},
            "food_stalls": {zone: {stall: [] for stall in food_stalls[zone]} for zone in food_stalls},
            "souvenir_shops": {zone: {shop: [] for shop in souvenir_shops[zone]} for zone in souvenir_shops}
        }
        self.wait_time_tracker = {zone: {ride: {"total_wait_time": 0, "num_visitors": 0}
                                         for ride in rides}
                                  for zone, rides in ride_properties.items()}

        # Ride states
        self.ride_queues = {zone: {ride: deque() for ride in rides} for zone, rides in ride_properties.items()}
        self.ride_active = {zone: {ride: {"occupied": 0, "timer": 0} for ride in rides} for zone, rides in ride_properties.items()}

        # Visitor entrance scheduling
        self.total_visitors = num_visitors
        self.remaining_visitors = num_visitors
        self.entrance_queue = list(range(num_visitors))  # List of visitor IDs to enter

        # Shuffle for randomness in entry order
        random.shuffle(self.entrance_queue)

    def get_most_crowded_zone(self):
        return max(self.zone_population, key=self.zone_population.get, default=None)

    def get_zone_from_position(self, pos):
      """Determines which USS zone a given position belongs to."""
      x, y = pos
      dx, dy = x - PARK_CENTER[0], y - PARK_CENTER[1]  # Get relative position from center

      if dx == 0 and dy == 0:
          return None  # At the center (water body), not in any zone

      angle = (math.degrees(math.atan2(dy, dx)) + 360) % 360  # Compute angle and normalize

      for zone, data in uss_zones.items():
          start_angle, end_angle = data["angle_range"]
          if start_angle <= angle < end_angle:
              return zone  # Return the corresponding zone name

      return None

    def update_zone_population(self):
      """Counts the number of visitors in each USS zone."""
      self.zone_population = {zone: 0 for zone in uss_zones}  # Reset visitor count

      for agent in self.schedule.agents:
          if isinstance(agent, Visitor) and agent.current_zone:
              self.zone_population[agent.current_zone] += 1

    def get_shortest_path(self, start, goal):
      queue = deque([(start, [])])
      visited = set()

      while queue:
          current, path = queue.popleft()
          if current == goal:
              return path

          # Skip if visited OR inside water body
          if current in visited or np.linalg.norm(np.array(current) - np.array(PARK_CENTER)) < WATER_RADIUS:
              continue

          visited.add(current)

          neighbors = self.grid.get_neighborhood(current, moore=True, include_center=False)
          for neighbor in neighbors:
              if np.linalg.norm(np.array(neighbor) - np.array(PARK_CENTER)) >= WATER_RADIUS:
                  queue.append((neighbor, path + [neighbor]))  # Only add valid paths

      return []  # If no valid path exists

    def step(self):
        """Runs a simulation step for the theme park."""
        current_time = self.start_time + self.time_per_step * self.schedule.time  # Calculate time
        print(f"Time: {current_time.strftime('%I:%M %p')}")
        # Handle visitor entrance in the first three steps
        if self.schedule.time < 3:  # Step 0 and Step 1
            if self.schedule.time == 0:
                num_to_enter = int(0.4 * self.total_visitors)  # 40% enter in step 0

            elif self.schedule.time == 1:
                num_to_enter = int(0.4 * self.total_visitors)  # 40% enter in step 1

            else:
                num_to_enter = self.remaining_visitors  # The rest enter in step 1

            for _ in range(num_to_enter):
                if self.entrance_queue:
                    visitor_id = self.entrance_queue.pop(0)
                    personality = random.choice(["explorer", "thrill-seeker", "family-oriented"])
                    visitor = Visitor(visitor_id, self)
                    self.grid.place_agent(visitor, (25, 5))  # Entrance location
                    self.schedule.add(visitor)

            self.remaining_visitors -= num_to_enter  # Update count of visitors left to enter
        if current_time.hour == 18 and current_time.minute >= 30 or current_time.hour >= 19:
            self.make_visitors_leave()

        self.schedule.step()
        self.update_rides()  # Update ride operations
        self.update_zone_population()  # Update visitor count


    def update_rides(self):
        """Handle ride operation cycles and move visitors from queue to ride."""
        for zone, rides in self.ride_active.items():
            for ride, data in rides.items():
                ride_capacity = ride_properties[zone][ride]["capacity"]
                ride_duration = ride_properties[zone][ride]["duration"]
                # to track queue
                queue_length = len(self.ride_queues[zone][ride])
                avg_wait_time = queue_length * (ride_duration / ride_capacity)  # Estimate avg wait
                self.wait_time_records["attractions"][zone][ride].append(avg_wait_time)

                # Check if ride is running
                if data["timer"] > 0:
                    data["timer"] -= 1  # Reduce timer
                    if data["timer"] == 0:
                        data["occupied"] = 0  # Ride empties
                else:
                    # Load new visitors if there's space
                    while self.ride_queues[zone][ride] and data["occupied"] < ride_capacity:
                        visitor = self.ride_queues[zone][ride].popleft()
                        data["occupied"] += 1
                        visitor.riding_time = ride_duration  # Set visitor's ride time

                    # Start new ride cycle if visitors are inside
                    if data["occupied"] > 0:
                        data["timer"] = ride_duration


    def make_visitors_leave(self):
        """Gradually makes visitors exit the park."""
        # Calculate the number of visitors to remove based on the time
        visitors_to_remove = []

        # Number of visitors leaving gradually (e.g., 10% of remaining visitors at each step)
        num_leaving = max(1, int(self.remaining_visitors * 0.05))  # 5% of remaining visitors leave per step
        visitors_left = [visitor for visitor in self.schedule.agents if isinstance(visitor, Visitor)]

        for visitor in visitors_left[:num_leaving]:
            visitors_to_remove.append(visitor)

        # Remove the selected visitors from the grid and schedule
        for visitor in visitors_to_remove:
            self.grid.remove_agent(visitor)
            self.schedule.remove(visitor)
            self.remaining_visitors -= 1  # Update the count of remaining visitors

        if self.remaining_visitors == 0:
            print("All visitors have left the park.")

    def get_final_wait_times(self):
    ##"""Returns the average wait time per attraction, food stall, and souvenir shop."""
        avg_wait_times = {
            category: {
                zone: {
                    place: (sum(times) / len(times) if times else 0)
                    for place, times in places.items()
                }
                for zone, places in self.wait_time_records[category].items()
            }
            for category in self.wait_time_records
        }
        return avg_wait_times

    def get_max_wait_times(self):
    ##"""Returns the average wait time per attraction, food stall, and souvenir shop."""
        max_wait_times = {
            category: {
                zone: {
                    place: (max(times) if times else 0)
                    for place, times in places.items()
                }
                for zone, places in self.wait_time_records[category].items()
            }
            for category in self.wait_time_records
        }
        return max_wait_times


"""### Wait Time Simulation (Control)"""

### to store the avg and max wait times
all_wait_times = []

park = ThemePark()
for s in range(TIME_STEPS):
    park.step()

    # Get average and maximum wait times
    avg_wait_times = park.get_final_wait_times()
    max_wait_times = park.get_max_wait_times()

    # Iterate through categories (attractions, food_stalls, souvenir_shops)
    for category in avg_wait_times:
        for zone in avg_wait_times[category]:
            for place in avg_wait_times[category][zone]:

                # record wait time
                all_wait_times.append({
                    "timestamp": s,
                    "zone": zone,
                    "place": place,
                    "average": avg_wait_times[category][zone][place],  # Average wait time
                    "maximum": max_wait_times[category][zone][place]  # Maximum wait time
                })

# Create the DataFrame
wait_times_df = pd.DataFrame(all_wait_times)

# Display or save the DataFrame
print("Wait Times DataFrame:")
display(wait_times_df)

### convert to csv file for storing
wait_times_df.to_csv("wait_times.csv", index=False)

"""## Change 1: Adjust capacities per ride"""

def adjust_capacity(data, capacity_change):
  for zone, rides in data.items():
    for ride, details in rides.items():
      capacity = details["capacity"]

      details["capacity"] = int(capacity * capacity_change)

  return data

ride_properties = adjust_capacity(ride_properties, 1.1) # 10% increase in capacities

ride_properties

"""### Wait Time Simulation (+10% Capacity Change)"""

### to store the avg and max wait times
change1_wait_times = []

park = ThemePark()
for s in range(TIME_STEPS):
    park.step()

    # Get average and maximum wait times
    avg_wait_times = park.get_final_wait_times()
    max_wait_times = park.get_max_wait_times()

    # Iterate through categories (attractions, food_stalls, souvenir_shops)
    for category in avg_wait_times:
        for zone in avg_wait_times[category]:
            for place in avg_wait_times[category][zone]:

                # record wait time
                change1_wait_times.append({
                    "timestamp": s,
                    "zone": zone,
                    "place": place,
                    "average": avg_wait_times[category][zone][place],  # Average wait time
                    "maximum": max_wait_times[category][zone][place]  # Maximum wait time
                })

# Create the DataFrame
change1_wait_times_df = pd.DataFrame(change1_wait_times)

# Display or save the DataFrame
print("Change1 Wait Times DataFrame:")
display(change1_wait_times_df)

### convert to csv file for storing
change1_wait_times_df.to_csv("change1_wait_times.csv", index=False)

"""## Change 2: Reduced Buffer Time (From 7 minutes to 5 minutes)"""

# Define ride capacities (max visitors per cycle) and operation times (steps per cycle)
# Original
ride_properties = {
    "Hollywood": {"Pantages Theater": {"capacity": 30, "duration": 3}, "Mel's Mixtape": {"capacity": 20, "duration": 2}, "Entrance": {"capacity": 100, "duration": 1}},
    "Minion Land": {"Minion Mayhem": {"capacity": 40, "duration": 5}, "Silly Swirly": {"capacity": 15, "duration": 3}, "Buggie Boogie": {"capacity": 10, "duration": 2}},
    "Far Far Away": {"Shrek 4D": {"capacity": 50, "duration": 6}, "Puss in Boots": {"capacity": 25, "duration": 4}, "Donkey LIVE": {"capacity": 30, "duration": 3},
                     "Magic Potion Spin": {"capacity": 15, "duration": 2}, "Enchanted Airways": {"capacity": 20, "duration": 4}},
    "The Lost World": {"Jurassic Rapids": {"capacity": 30, "duration": 5}, "Canopy Flyer": {"capacity": 20, "duration": 3}, "Dino-Soarin": {"capacity": 15, "duration": 2},
                       "Water World": {"capacity": 60, "duration": 8}},
    "Ancient Egypt": {"Revenge of Mummy": {"capacity": 25, "duration": 4}, "Treasure Hunters": {"capacity": 10, "duration": 2}},
    "Sci-Fi City": {"Transformers": {"capacity": 40, "duration": 5}, "Cylon": {"capacity": 30, "duration": 4}, "Human": {"capacity": 30, "duration": 4},
                    "Accelerator": {"capacity": 15, "duration": 2}},
    "New York": {"Sesame Street Spaghetti Chase": {"capacity": 20, "duration": 3}, "Rhythm Truck": {"capacity": 10, "duration": 2}, "Lights Camera Action!": {"capacity": 25, "duration": 4}},
}

def adjust_duration(data, duration_change):
  for zone, rides in data.items():
    for ride, details in rides.items():
      duration = details["duration"]

      details["duration"] = int(duration + duration_change)

  return data

# adjust such that to account for 7 minute buffer
ride_properties = adjust_duration(ride_properties, 5)

ride_properties

"""### Wait Time Simulation (Buffer Time Reduce from 7 min to 5 min)"""

### to store the avg and max wait times
change2_wait_times = []

park = ThemePark()
for s in range(TIME_STEPS):
    park.step()

    # Get average and maximum wait times
    avg_wait_times = park.get_final_wait_times()
    max_wait_times = park.get_max_wait_times()

    # Iterate through categories (attractions, food_stalls, souvenir_shops)
    for category in avg_wait_times:
        for zone in avg_wait_times[category]:
            for place in avg_wait_times[category][zone]:

                # record wait time
                change2_wait_times.append({
                    "timestamp": s,
                    "zone": zone,
                    "place": place,
                    "average": avg_wait_times[category][zone][place],  # Average wait time
                    "maximum": max_wait_times[category][zone][place]  # Maximum wait time
                })

# Create the DataFrame
change2_wait_times_df = pd.DataFrame(change2_wait_times)

# Display or save the DataFrame
print("Change2 Wait Times DataFrame:")
display(change2_wait_times_df)

### convert to csv file for storing
change2_wait_times_df.to_csv("change2_wait_times.csv", index=False)

"""## Change 3: Rotate Zones to test out wait times (Still need to amend)"""

# Constants for the park
PARK_CENTER = (25, 25)
PARK_RADIUS = 20
WATER_RADIUS = 5  # The central water body
TIME_STEPS = 20  # 10 AM to 8 PM in 30 min intervals

# Redefine USS zones with angles and colors
uss_zones = {
    "Minion Land": {"angle_range": (265, 290), "color": "yellow"},
    "Far Far Away": {"angle_range": (290, 360), "color": "grey"},
    "The Lost World": {"angle_range": (0, 65), "color": "green"},
    "Ancient Egypt": {"angle_range": (65, 130), "color": "brown"},
    "Sci-Fi City": {"angle_range": (130, 170), "color": "blue"},
    "New York": {"angle_range": (170, 205), "color": "red"},
    "Hollywood": {"angle_range": (205, 265), "color": "purple"},
    #"Entrance": {"angle_range": (225, 270), "color": "gray"},
}

# Fixed locations for attractions
attractions = {
    "Hollywood": [(28, 18, "Pantages Theater"), (26, 19, "Mel's Mixtape"), (26,5,"Entrance")],
    "Minion Land": [(40, 25, "Minion Mayhem"), (35, 24, "Silly Swirly"), (34,23,"Buggie Boogie")],
    "Far Far Away": [(38, 29, "Shrek 4D"), (33, 39, "Puss in Boots"),(37,39,"Donkey LIVE"),(38,32,"Magic Potion Spin"),(34,27,"Enchanted Airways")],
    "The Lost World": [(16, 37, "Jurassic Rapids"), (26, 38, "Canopy Flyer"), (27, 39,"Dino-Soarin"), (30,38,"Water World")],
    "Ancient Egypt": [(13, 32, "Revenge of Mummy"), (17, 32, "Treasure Hunters")],
    "Sci-Fi City": [(11, 20, "Transformers"), (10, 24, "Cylon"), (10, 25, "Human"), (10, 23, "Accelerator")],
    "New York": [(22, 16, "Sesame Street Spaghetti Chase"), (23, 17, "Rhythm Truck"), (22, 17, "Lights Camera Action!")],
}
# Fixed locations for food stalls
food_stalls = {
    "Hollywood": [(29, 15, "Mel's Drive-In")],
    "Minion Land": [(38, 20, "Pop-A-Nana")],
    "Far Far Away": [(36, 27, "Goldilocks")],
    "The Lost World": [(28, 35, "Discovery Food Court")],
    "Ancient Egypt": [(15, 30, "Oasis Cafe")],
    "Sci-Fi City": [(12.5, 20, "StarBot Cafe")],
    "New York": [(20, 10, "Louie's NY Pizza")],
}

# Fixed locations for souvenir shops
souvenir_shops = {
    "Hollywood": [(25,14,"Candylicious"),(27,6,"Hello Kitty Studio Store"), (28,6,"Minion Mart"),(29,6,"Universal Studios Store"),(25,15,"UNIVRS")],
    "Minion Land": [(37,19,"Sweet Surrender"),(39,24,"Pop Store"), (34,22,"Fun Store")],
    "Far Far Away": [(35,26,"Fairy Godmother's Potion Shop")],
    "The Lost World": [(27,34,"The Dino-Store")],
    "Ancient Egypt": [(16,31,"Carter's Curiosities")],
    "Sci-Fi City": [(12,21,"Transformers shop")],
    "New York":[(21,9,"Big Bird's Emporium")]
}

# Popularity weights for attractions (Higher values mean more popular-based off of wait time predictions)
attraction_weights = {
    "Hollywood": {"Pantages Theater": 2, "Mel's Mixtape": 1, "Entrance": 1},
    "Minion Land": {"Minion Mayhem": 5, "Silly Swirly": 3, "Buggie Boogie": 3},
    "Far Far Away": {"Shrek 4D": 4, "Puss in Boots": 3, "Donkey LIVE": 3, "Magic Potion Spin": 2, "Enchanted Airways": 3},
    "The Lost World": {"Jurassic Rapids": 4, "Canopy Flyer": 3, "Dino-Soarin": 2, "Water World": 5},
    "Ancient Egypt": {"Revenge of Mummy": 5, "Treasure Hunters": 3},
    "Sci-Fi City": {"Transformers": 5, "Cylon": 4, "Human": 4, "Accelerator": 3},
    "New York": {"Sesame Street Spaghetti Chase": 3, "Rhythm Truck": 2, "Lights Camera Action!": 4},
}

# Define ride capacities (max visitors per cycle) and operation times (steps per cycle)
ride_properties = {
    "Hollywood": {"Pantages Theater": {"capacity": 30, "duration": 3}, "Mel's Mixtape": {"capacity": 20, "duration": 2}, "Entrance": {"capacity": 100, "duration": 1}},
    "Minion Land": {"Minion Mayhem": {"capacity": 40, "duration": 5}, "Silly Swirly": {"capacity": 15, "duration": 3}, "Buggie Boogie": {"capacity": 10, "duration": 2}},
    "Far Far Away": {"Shrek 4D": {"capacity": 50, "duration": 6}, "Puss in Boots": {"capacity": 25, "duration": 4}, "Donkey LIVE": {"capacity": 30, "duration": 3},
                     "Magic Potion Spin": {"capacity": 15, "duration": 2}, "Enchanted Airways": {"capacity": 20, "duration": 4}},
    "The Lost World": {"Jurassic Rapids": {"capacity": 30, "duration": 5}, "Canopy Flyer": {"capacity": 20, "duration": 3}, "Dino-Soarin": {"capacity": 15, "duration": 2},
                       "Water World": {"capacity": 60, "duration": 8}},
    "Ancient Egypt": {"Revenge of Mummy": {"capacity": 25, "duration": 4}, "Treasure Hunters": {"capacity": 10, "duration": 2}},
    "Sci-Fi City": {"Transformers": {"capacity": 40, "duration": 5}, "Cylon": {"capacity": 30, "duration": 4}, "Human": {"capacity": 30, "duration": 4},
                    "Accelerator": {"capacity": 15, "duration": 2}},
    "New York": {"Sesame Street Spaghetti Chase": {"capacity": 20, "duration": 3}, "Rhythm Truck": {"capacity": 10, "duration": 2}, "Lights Camera Action!": {"capacity": 25, "duration": 4}},
}

### Adjust the Duration of rides to accommodate for buffer for rides.

def adjust_duration(data, duration_change):
  for zone, rides in data.items():
    for ride, details in rides.items():
      duration = details["duration"]

      details["duration"] = int(duration + duration_change)

  return data

# adjust such that to account for 7 minute buffer
ride_properties = adjust_duration(ride_properties, 7)

"""### Wait Time Simulation (Zone Rotation)"""

### to store the avg and max wait times
change3_wait_times = []

park = ThemePark()
for s in range(TIME_STEPS):
    park.step()

    # Get average and maximum wait times
    avg_wait_times = park.get_final_wait_times()
    max_wait_times = park.get_max_wait_times()

    # Iterate through categories (attractions, food_stalls, souvenir_shops)
    for category in avg_wait_times:
        for zone in avg_wait_times[category]:
            for place in avg_wait_times[category][zone]:

                # record wait time
                change3_wait_times.append({
                    "timestamp": s,
                    "zone": zone,
                    "place": place,
                    "average": avg_wait_times[category][zone][place],  # Average wait time
                    "maximum": max_wait_times[category][zone][place]  # Maximum wait time
                })
# Create the DataFrame
change3_wait_times_df = pd.DataFrame(change3_wait_times)

# Display or save the DataFrame
print("Change3 Wait Times DataFrame:")
display(change3_wait_times_df)

### convert to csv file for storing
change3_wait_times_df.to_csv("change3_wait_times.csv", index=False)

"""# Assessment of Impacts

Assess Impact on Wait time, Satisfaction and Revenue:

1. Consider correlation analysis between factors affecting guest satisfaction (determine importance of wait time in affecting guest experience)

2. Understand the distribution of Attraction/Service, may be able to have staggered opening/closing to reduce operational cost, increasing revenue.

## Wait Time Plots

### Control
"""

# Load CSV (Time column formatted)
df_control = pd.read_csv('control_wait_times.csv')

# Convert 'timestamp' to datetime objects
df_control['timestamp'] = pd.to_datetime(df_control['timestamp'])

# Extract the time part of the timestamp and convert it to total minutes since midnight
df_control['time_minutes'] = df_control['timestamp'].dt.hour * 60 + df_control['timestamp'].dt.minute

# --- Create a new column with formatted time ---
df_control['time_formatted'] = pd.to_datetime(df_control['time_minutes'], unit='m').dt.strftime('%H:%M')

# Define a threshold for 'long' wait times (using 'average' wait time)
long_wait_time_threshold = 20  # minutes (adjust as needed)

# Filter data for long wait times
long_wait_times_df = df_control[df_control['average'] >= long_wait_time_threshold]

# Create a scatter plot highlighting long wait times
plt.figure(figsize=(10, 8))

# --- Control: Use time_formatted for x-axis ---
sns.scatterplot(data=df_control, x='time_formatted', y='place', hue='average',
                palette='viridis', size='average', sizes=(50, 200))

# Highlight long wait times with a different marker
sns.scatterplot(data=long_wait_times_df, x='time_formatted', y='place', color='red',
                marker='x', s=100, label=f'Average Wait Time >= {long_wait_time_threshold} mins')

plt.title('Control Wait Time Heat Map')
plt.xlabel('Time of Day')  # Update x-axis label
plt.ylabel('Place')
plt.legend()
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for readability
plt.show()

"""### Change 1: +10% Capacity"""

# Load CSV (Time column formatted)
df_c1 = pd.read_csv('formatted_change1_wait_times.csv')

# Convert 'timestamp' to datetime objects
df_c1['timestamp'] = pd.to_datetime(df_c1['timestamp'])

# Extract the time part of the timestamp and convert it to total minutes since midnight
df_c1['time_minutes'] = df_c1['timestamp'].dt.hour * 60 + df_c1['timestamp'].dt.minute

# --- Create a new column with formatted time ---
df_c1['time_formatted'] = pd.to_datetime(df_c1['time_minutes'], unit='m').dt.strftime('%H:%M')

# Define a threshold for 'long' wait times (using 'average' wait time)
long_wait_time_threshold = 20  # minutes (adjust as needed)

# Filter data for long wait times
long_wait_times_df = df_c1[df_c1['average'] >= long_wait_time_threshold]

# Create a scatter plot highlighting long wait times
plt.figure(figsize=(10, 8))

# --- Change 1: Use time_formatted for x-axis ---
sns.scatterplot(data=df_c1, x='time_formatted', y='place', hue='average',
                palette='viridis', size='average', sizes=(50, 200))

# Highlight long wait times with a different marker
sns.scatterplot(data=long_wait_times_df, x='time_formatted', y='place', color='red',
                marker='x', s=100, label=f'Average Wait Time >= {long_wait_time_threshold} mins')

plt.title('Change in Capacity Wait Time Heat Map')
plt.xlabel('Time of Day')  # Update x-axis label
plt.ylabel('Place')
plt.legend()
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for readability
plt.show()

"""### Change 2: Reduced Buffer Time between each ride (7 Minute for control to 5 Minute)"""

# Load CSV (Time column formatted)
df_c2 = pd.read_csv('formatted_change2_wait_times.csv')

# Convert 'timestamp' to datetime objects
df_c2['timestamp'] = pd.to_datetime(df_c2['timestamp'])

# Extract the time part of the timestamp and convert it to total minutes since midnight
df_c2['time_minutes'] = df_c2['timestamp'].dt.hour * 60 + df_c2['timestamp'].dt.minute

# --- Create a new column with formatted time ---
df_c2['time_formatted'] = pd.to_datetime(df_c2['time_minutes'], unit='m').dt.strftime('%H:%M')

# Define a threshold for 'long' wait times (using 'average' wait time)
long_wait_time_threshold = 20  # minutes (adjust as needed)

# Filter data for long wait times
long_wait_times_df = df_c2[df_c2['average'] >= long_wait_time_threshold]

# Create a scatter plot highlighting long wait times
plt.figure(figsize=(10, 8))

# --- Change 2: Use time_formatted for x-axis ---
sns.scatterplot(data=df_c2, x='time_formatted', y='place', hue='average',
                palette='viridis', size='average', sizes=(50, 200))

# Highlight long wait times with a different marker
sns.scatterplot(data=long_wait_times_df, x='time_formatted', y='place', color='red',
                marker='x', s=100, label=f'Average Wait Time >= {long_wait_time_threshold} mins')

plt.title('Change in Buffer Time Wait Time Heat Map')
plt.xlabel('Time of Day')  # Update x-axis label
plt.ylabel('Place')
plt.legend()
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for readability
plt.show()

"""### Change 3: Zone Rotation"""

# Load CSV (Time column formatted)
df_c3 = pd.read_csv('formatted_change3_wait_times.csv')

# Convert 'timestamp' to datetime objects
df_c3['timestamp'] = pd.to_datetime(df_c3['timestamp'])

# Extract the time part of the timestamp and convert it to total minutes since midnight
df_c3['time_minutes'] = df_c3['timestamp'].dt.hour * 60 + df_c3['timestamp'].dt.minute

# --- Create a new column with formatted time ---
df_c3['time_formatted'] = pd.to_datetime(df_c3['time_minutes'], unit='m').dt.strftime('%H:%M')

# Define a threshold for 'long' wait times (using 'average' wait time)
long_wait_time_threshold = 20  # minutes (adjust as needed)

# Filter data for long wait times
long_wait_times_df = df_c3[df_c3['average'] >= long_wait_time_threshold]

# Create a scatter plot highlighting long wait times
plt.figure(figsize=(10, 8))

# --- Change 3: Use time_formatted for x-axis ---
sns.scatterplot(data=df_c3, x='time_formatted', y='place', hue='average',
                palette='viridis', size='average', sizes=(50, 200))

# Highlight long wait times with a different marker
sns.scatterplot(data=long_wait_times_df, x='time_formatted', y='place', color='red',
                marker='x', s=100, label=f'Average Wait Time >= {long_wait_time_threshold} mins')

plt.title('Change in Zone Wait Time Heat Map')
plt.xlabel('Time of Day')  # Update x-axis label
plt.ylabel('Place')
plt.legend()
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for readability
plt.show()

"""### Comparison Plot for ALL: Control, C1, C2, C3"""

# Create a figure with subplots for each scenario
fig, axes = plt.subplots(2, 2, figsize=(15, 12))

# Function to create a scatter plot for a given dataframe and subplot axis
def plot_wait_times(df, ax, title):
  long_wait_time_threshold = 20
  long_wait_times_df = df[df['average'] >= long_wait_time_threshold]

  sns.scatterplot(data=df, x='time_formatted', y='place', hue='average',
                  palette='viridis', size='average', sizes=(50, 200), ax=ax)
  sns.scatterplot(data=long_wait_times_df, x='time_formatted', y='place', color='red',
                  marker='x', s=100, label=f'Average Wait Time >= {long_wait_time_threshold} mins', ax=ax)

  ax.set_title(title)
  ax.set_xlabel('Time of Day')
  ax.set_ylabel('Place')
  ax.legend()
  ax.tick_params(axis='x', rotation=45, labelsize=8)


# Plot each scenario in its respective subplot
plot_wait_times(df_control, axes[0, 0], 'Control Wait Time Heat Map')
plot_wait_times(df_c1, axes[0, 1], 'Change in Capacity Wait Time Heat Map')
plot_wait_times(df_c2, axes[1, 0], 'Change in Buffer Time Wait Time Heat Map')
plot_wait_times(df_c3, axes[1, 1], 'Change in Zone Wait Time Heat Map')


# Adjust layout and spacing
plt.tight_layout()

# Show the plot
plt.show()

# Function to calculate the rate of reduction in wait time for maximum wait time
def calculate_reduction_rate(df_base, df_change, place_name):

  base_wait_times = df_base[df_base['place'] == place_name]['maximum'].max()
  change_wait_times = df_change[df_change['place'] == place_name]['maximum'].max()

  if base_wait_times == 0:
    return float('inf')
  else:
    reduction_rate = ((change_wait_times - base_wait_times) / base_wait_times)
    return reduction_rate

# Create lists to store reduction rates for each change
c1_reduction_rates = []
c2_reduction_rates = []
c3_reduction_rates = []

# Iterate through each place and calculate the rate of reduction
places = df_control['place'].unique()
for place in places:
  # Calculate reduction rates for each change compared to the control
  c1_reduction_rate = calculate_reduction_rate(df_control, df_c1, place)
  c2_reduction_rate = calculate_reduction_rate(df_control, df_c2, place)
  c3_reduction_rate = calculate_reduction_rate(df_control, df_c3, place)

  c1_reduction_rates.append(c1_reduction_rate)
  c2_reduction_rates.append(c2_reduction_rate)
  c3_reduction_rates.append(c3_reduction_rate)

  # print(f"Place: {place}")
  # print(f"  Change 1 Reduction Rate: {c1_reduction_rate}")
  # print(f"  Change 2 Reduction Rate: {c2_reduction_rate}")
  # print(f"  Change 3 Reduction Rate: {c3_reduction_rate}")

# Create a bar chart to visualize the reduction rates
plt.figure(figsize=(10, 6))
bar_width = 0.2
index = range(len(places))

plt.bar(index, c1_reduction_rates, width=bar_width, label='Change 1')
plt.bar([i + bar_width for i in index], c2_reduction_rates, width=bar_width, label='Change 2')
plt.bar([i + 2 * bar_width for i in index], c3_reduction_rates, width=bar_width, label='Change 3')

plt.xlabel('Place')
plt.ylabel('Reduction Rate')
plt.title('Reduction Rate of Maximum Wait Time')
plt.xticks([i + bar_width for i in index], places, rotation=45, ha='right')
plt.legend()
plt.tight_layout()
plt.show()

def avg_calculate_reduction_rate(df_base, df_change, place_name):

  base_wait_times = df_base[df_base['place'] == place_name]['average'].max()
  change_wait_times = df_change[df_change['place'] == place_name]['average'].max()

  if base_wait_times == 0:
    return float('inf')
  else:
    reduction_rate = ((change_wait_times - base_wait_times) / base_wait_times)
    return reduction_rate

# Create lists to store reduction rates for each change
avg_c1_reduction_rates = []
avg_c2_reduction_rates = []
avg_c3_reduction_rates = []

# Iterate through each place and calculate the rate of reduction
places = df_control['place'].unique()
for place in places:
  # Calculate reduction rates for each change compared to the control
  c1_reduction_rate = avg_calculate_reduction_rate(df_control, df_c1, place)
  c2_reduction_rate = avg_calculate_reduction_rate(df_control, df_c2, place)
  c3_reduction_rate = avg_calculate_reduction_rate(df_control, df_c3, place)

  avg_c1_reduction_rates.append(c1_reduction_rate)
  avg_c2_reduction_rates.append(c2_reduction_rate)
  avg_c3_reduction_rates.append(c3_reduction_rate)

  # print(f"Place: {place}")
  # print(f"  Change 1 Reduction Rate: {c1_reduction_rate}")
  # print(f"  Change 2 Reduction Rate: {c2_reduction_rate}")
  # print(f"  Change 3 Reduction Rate: {c3_reduction_rate}")

# Create a bar chart to visualize the reduction rates
plt.figure(figsize=(10, 6))
bar_width = 0.2
index = range(len(places))

plt.bar(index, avg_c1_reduction_rates, width=bar_width, label='Change 1')
plt.bar([i + bar_width for i in index], avg_c2_reduction_rates, width=bar_width, label='Change 2')
plt.bar([i + 2 * bar_width for i in index], avg_c3_reduction_rates, width=bar_width, label='Change 3')

plt.xlabel('Place')
plt.ylabel('Reduction Rate')
plt.title('Reduction Rate of Maximum Wait Time')
plt.xticks([i + bar_width for i in index], places, rotation=45, ha='right')
plt.legend()
plt.tight_layout()
plt.show()

"""### Assess of Wait Time on Guest Satisfaction

Show that reduced wait times increases overall guest satisfaction:
"""

### RIDES AND ATTRACTION:

rating_col = "Question 17.2: Give an overall rating for rides and attractions"  # Column storing Likert scale ratings (1-5)
dissatisfaction_col = "Question 18.2: For rides and attractions, which of the following services are you not satisfied with?"  # Column storing dissatisfaction reasons

# Create a list to store new DataFrame rows
new_rows = []

for index, row in survey_data.iterrows():
    dissatisfaction_reasons = str(row[dissatisfaction_col]).split(',')  # Split by comma
    for reason in dissatisfaction_reasons:
        reason = reason.strip()  # Remove leading/trailing spaces
        if reason:  # If reason is not empty
            new_row = row.copy()  # Create a copy of the original row
            new_row[dissatisfaction_col] = reason  # Assign the single reason
            new_rows.append(new_row)

# Create a new DataFrame with separated reasons
separated_data = pd.DataFrame(new_rows)

# Filter out unwanted reasons
filtered_data = separated_data[~separated_data[dissatisfaction_col].isin(["Not taking into account soft toy like me!", "nan"])]

# Group by rating and dissatisfaction reason and count occurrences
dissatisfaction_counts = filtered_data.groupby([rating_col, dissatisfaction_col]).size().unstack(fill_value=0)

# Plot the heatmap
plt.figure(figsize=(12, 8))  # Adjust size as needed
sns.heatmap(dissatisfaction_counts.T, cmap="coolwarm", annot=True, fmt="d")
plt.xlabel("Overall Rating (Likert Scale 1-5)")
plt.ylabel("Dissatisfaction Factors (Separated)")
plt.title("Dissatisfaction Factors vs. Overall Ride Rating (Separated)")
plt.show()

### FNB

rating_col = "Question 17.4: Give an overall rating for food and beverage"  # Column storing Likert scale ratings (1-5)
dissatisfaction_col = "Question 18.4: For food and beverage, which of the following services are you not satisfied with?"  # Column storing dissatisfaction reasons

# Create a list to store new DataFrame rows
new_rows = []

for index, row in survey_data.iterrows():
    dissatisfaction_reasons = str(row[dissatisfaction_col]).split(',')  # Split by comma
    for reason in dissatisfaction_reasons:
        reason = reason.strip()  # Remove leading/trailing spaces
        if reason:  # If reason is not empty
            new_row = row.copy()  # Create a copy of the original row
            new_row[dissatisfaction_col] = reason  # Assign the single reason
            new_rows.append(new_row)

# Create a new DataFrame with separated reasons
separated_data = pd.DataFrame(new_rows)

# Filter out unwanted reasons
filtered_data = separated_data[~separated_data[dissatisfaction_col].isin(["nan"])]

# Group by rating and dissatisfaction reason and count occurrences
dissatisfaction_counts = filtered_data.groupby([rating_col, dissatisfaction_col]).size().unstack(fill_value=0)

# Plot the heatmap
plt.figure(figsize=(12, 8))  # Adjust size as needed
sns.heatmap(dissatisfaction_counts.T, cmap="coolwarm", annot=True, fmt="d")
plt.xlabel("Overall Rating (Likert Scale 1-5)")
plt.ylabel("Dissatisfaction Factors (Separated)")
plt.title("Dissatisfaction Factors vs. Overall FNB Rating (Separated)")
plt.show()
